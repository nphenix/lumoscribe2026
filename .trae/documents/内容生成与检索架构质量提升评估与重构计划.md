## 现状架构概览
- **内容生成主编排**集中在 [service.py](file:///f:/lumoscribe2026/src/application/services/content_generation/service.py)，同时承担模板解析、RAG 组装、自动图表抽取、逐章 LLM、HTML 渲染、旧接口兼容与大纲润色等职责。
- **LLM 运行时中枢**在 [llm_runtime_service.py](file:///f:/lumoscribe2026/src/application/services/llm_runtime_service.py)，以 CallSite 为入口构建 LangChain Runnable / 模型实例，并负责 Prompt 装配。
- **RAG/检索层**主要在 [hybrid_search_service.py](file:///f:/lumoscribe2026/src/application/services/hybrid_search_service.py)（QueryFusionRetriever + RecursiveRetriever + rerank 注入）与 [vector_storage_service.py](file:///f:/lumoscribe2026/src/application/services/vector_storage_service.py)（Chroma + LlamaIndex Index/StorageContext）。
- **大纲润色存在两条链路**：
  - content_generation 内置同步调用：`content_generation:polish_outline`（见 [service.py:polish_outline](file:///f:/lumoscribe2026/src/application/services/content_generation/service.py#L835-L845)）
  - outline_polish 模块 Agent：`outline_polish:polish`（见 [outline_polish_service.py](file:///f:/lumoscribe2026/src/application/services/outline_polish/outline_polish_service.py)）

## DRY/SOLID 问题清单（按影响排序）
- **SRP 违反（单一职责过载）**：`ContentGenerationService` 是“上帝类”，核心方法 `assemble_context_for_section()` 混合了并发召回、覆盖评估、去重、来源名清洗、自动图表抽取、截断与事件上报（见 [service.py:173-439](file:///f:/lumoscribe2026/src/application/services/content_generation/service.py#L173-L439)）。
- **重复实现（DRY）**：同文件内 `_is_bad_title()` 被定义了两次（见 [service.py:219-231](file:///f:/lumoscribe2026/src/application/services/content_generation/service.py#L219-L231) 与 [service.py:462-474](file:///f:/lumoscribe2026/src/application/services/content_generation/service.py#L462-L474)）。
- **异步阻塞风险（可靠性/性能）**：
  - `ContentGenerationService.polish_outline()` 在 async 路由链路中被调用但内部 `invoke()` 为同步网络 IO，可能阻塞 event loop（[service.py:835-845](file:///f:/lumoscribe2026/src/application/services/content_generation/service.py#L835-L845)）。
  - `OutlinePolishService.polish_outline()` 是 async 函数但内部 `agent.invoke()` 同步执行（[outline_polish_service.py:121-208](file:///f:/lumoscribe2026/src/application/services/outline_polish/outline_polish_service.py#L121-L208)）。
- **Prompt 获取/装配逻辑重复**：`PromptService.get_active_prompt()`、`PromptRepository.get_active_prompt()`、`LLMRuntimeService._get_active_prompt()` 语义重叠，导致边界不清、后续演进困难（见 [prompt_service.py](file:///f:/lumoscribe2026/src/application/services/prompt_service.py) 与 [llm_runtime_service.py:1105-1114](file:///f:/lumoscribe2026/src/application/services/llm_runtime_service.py#L1105-L1114)）。
- **接口一致性/单一事实来源不清**：CallSite 播种在 [init-db.py](file:///f:/lumoscribe2026/scripts/init-db.py) 与 [app.py](file:///f:/lumoscribe2026/src/interfaces/api/app.py#L25-L60) 两处存在相似逻辑。
- **配置一致性风险（Embedding）**：切分服务 [chunking_service.py](file:///f:/lumoscribe2026/src/application/services/chunking_service.py) 内部自建 HuggingFaceEmbedding，而向量层 [vector_storage_service.py](file:///f:/lumoscribe2026/src/application/services/vector_storage_service.py) 支持注入 embedding（两处可能导致同一 KB 链路 embedding 不一致）。
- **技术债信号**：`HybridSearchService` 顶部 imports 中有多项未必使用/与实现重复的路径（同文件前半段），同时存在“预建 BM25 索引”和“QueryFusionRetriever(BM25Retriever.from_defaults)”两套 BM25 来源。
- **你提到的 TTsending**：全仓未检索到对应标识符/模块名，当前不在重构触达范围内（可按你的要求忽略）。

## LangChain / LlamaIndex 最佳实践核对（联网结论对照）
- **LangChain（LCEL/Runnables）**：你们在 `LLMRuntimeService.build_runnable_for_callsite()` 使用 `prompt | llm | StrOutputParser()` 组合是推荐的 LCEL 方式（对照 LangChain Runnables/LCEL 文档）。
- **LangChain（异步/流式）**：建议在 async 场景优先使用 `ainvoke/astream`；你们的章节生成已正确用 `astream` 或 `run_in_executor`（见 [llm_section.py](file:///f:/lumoscribe2026/src/application/services/content_generation/llm_section.py)），但大纲润色两条链路目前存在同步调用。
- **LangChain（Structured Output）**：当前 outline_polish 使用 `ToolStrategy(PydanticModel)` 方向符合“结构化输出”推荐；但建议将同步 invoke 改为 `ainvoke` 或显式放入线程池，避免阻塞。
- **LlamaIndex v0.14.6（Chroma + 持久化）**：`VectorStoreIndex + ChromaVectorStore + StorageContext.persist/load` 是文档推荐路径；你们使用 `StorageContext.from_defaults(...)` 并缓存 index 的设计总体合理（对照 v0.14.6 示例）。
- **LlamaIndex（Hybrid Retriever）**：官方示例倾向 `QueryFusionRetriever([dense_retriever, BM25Retriever], use_async=True)`；你们在 [hybrid_search_service.py:439-453](file:///f:/lumoscribe2026/src/application/services/hybrid_search_service.py#L439-L453) 已采用该方式。

## 拟定重构目标（你确认后才会实施）
- **DRY**：消除重复的标题判定、重复的 prompt/callsite 获取逻辑、重复的入口编排代码。
- **SOLID**：将“检索上下文组装 / 覆盖评估 / 自动图表抽取 / 文本截断 / 事件发射”等拆分为职责单一组件；ContentGenerationService 退化为 Orchestrator。
- **一致性**：统一 async 调用模型的方式；统一 embedding 来源；统一大纲润色能力入口。

## 实施计划（需你同意后执行）
### 1) 边界与抽象（SRP/ISP）
- 新增小型组件/函数（放在现有模块目录内，避免引入新层级）：
  - `TitleQuality`（统一 `_is_bad_title`）
  - `ContextTruncator`（统一 max chars 截断策略）
  - `CoverageRecorder`（专门负责 coverage 条目构造）
  - `ContextBlockBuilder`（负责“来源/片段”块的标准化拼装）
  - `OutlineRecallPlanner`（负责并发召回与限流策略）

### 2) 拆分 assemble_context_for_section（DRY + SRP）
- 将 [assemble_context_for_section](file:///f:/lumoscribe2026/src/application/services/content_generation/service.py#L173-L439) 拆成 4-6 个纯函数/小类：
  - 解析 outline → 生成 skeleton
  - 并发检索（只返回 raw hits）
  - 选取/去重/来源展示名决策
  - coverage 生成
  - auto chart 抽取
  - 最终 context 合成 + 截断

### 3) 统一大纲润色（OCP/LSP）
- 选定一个“对外能力”的规范入口（建议保留一个 scope，另一条链路调用它）：
  - 方案 A：以 `outline_polish` 为主（结构化输出），content_generation 复用其 Service。
  - 方案 B：以 `content_generation:polish_outline` 为主（纯文本），outline_polish 退化为包装层。
- 同步/异步一致化：全部改为 async 并在内部使用 `ainvoke` 或 `run_in_executor`。
- Prompt 渲染避免 `.format()` 造成 `{}` 冲突：改为更安全的替换策略（与你们提示词规范一致）。

### 4) 统一 Prompt 获取（DIP）
- 明确“Prompt 的权威入口”只保留一处（建议 PromptService），`LLMRuntimeService` 通过服务获取 active prompt，减少重复。

### 5) Embedding 一致性（DIP/配置化）
- 将 `DocumentChunkingService` 改为支持注入 embedding（与 VectorStorageService 一致），并将默认 HF embedding 作为 fallback。

### 6) 清理检索技术债与重复路径
- HybridSearch：明确 BM25 来源（预建索引 vs QueryFusionRetriever）与使用场景，避免两套逻辑并存造成维护成本。
- 清理未使用 imports/不可达分支（不改变行为的前提下）。

### 7) 验证策略
- 单元测试：
  - 标题判定、context block 生成、截断策略、去重逻辑
  - outline polish 渲染（含包含 `{}` 的 prompt 场景）
- 集成测试（已有 tests 基础上扩展）：
  - HybridSearch 返回结构、rerank 降级、chart_children 递归扩展
- 性能/行为回归：
  - 对比重构前后同一输入的 coverage 统计与生成输出结构（允许文本差异，但结构/锚点规则必须一致）。

如果你确认这个重构方向，我将按上述顺序开始落地代码改动，并在每个阶段给出可审阅的差异与回归验证结果。