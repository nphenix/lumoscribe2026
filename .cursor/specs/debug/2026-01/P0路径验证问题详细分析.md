# P0 路径验证问题详细分析

> **问题位置**: `src/application/services/knowledge_base_service.py:496-579`  
> **问题类型**: 路径结构判断逻辑脆弱，缺少严格验证  
> **严重程度**: P0（可能导致构建失败）

## 1. 问题代码位置

### 1.1 核心代码片段

```python
# knowledge_base_service.py:496-579
root_kind = root_abs.name.lower()
if root_kind == "pic_to_json":
    md_files = sorted([p for p in root_abs.glob("*.md") if p.is_file()])
    if len(md_files) != 1:
        raise AppError(
            code="kb_invalid_input",
            message=f"pic_to_json 目录下应且仅应包含 1 个 md 文件: {root}（实际: {len(md_files)}）",
            status_code=400,
        )
else:
    md_files = sorted(root_abs.rglob("full.md"))
    if not md_files:
        md_files = sorted([p for p in root_abs.rglob("*.md") if p.is_file()])

# ... 后续处理 ...

for i, md_path in enumerate(md_files, start=1):
    doc_dir = md_path.parent
    rel = md_path.relative_to(root_abs)
    md_text = _safe_read_text(md_path)
    doc_title = _pick_doc_title(doc_dir, md_text)

    if root_kind == "pic_to_json":
        source_file_id = root_abs.parent.name  # ⚠️ 关键：依赖 parent.name 是 UUID
        doc_id = md_path.stem
    else:
        uuid_parts = _uuid_parts_from_relpath(rel)
        source_file_id = uuid_parts[0] if len(uuid_parts) >= 1 else "unknown"
        doc_id = uuid_parts[1] if len(uuid_parts) >= 2 else doc_dir.name
```

## 2. 代码执行路径分析

### 2.1 正常执行路径（当前路径结构）

**输入路径**: `data/intermediates/{source_file_id}/pic_to_json`

**执行流程**:
```
1. root = Path("data/intermediates/{source_file_id}/pic_to_json")
2. root_abs = root.resolve()  # 绝对路径
3. root_kind = root_abs.name.lower()  # "pic_to_json" ✅
4. if root_kind == "pic_to_json":  # True
5.   md_files = root_abs.glob("*.md")  # 查找 pic_to_json 目录下的 md 文件
6.   if len(md_files) != 1:  # 期望只有 1 个
7.     raise AppError(...)
8. 
9. # 后续处理
10. for md_path in md_files:
11.   if root_kind == "pic_to_json":
12.     source_file_id = root_abs.parent.name  # intermediates/{id}/pic_to_json 的 parent 是 {id} ✅
13.     doc_id = md_path.stem
```

**当前路径结构下的行为**: ✅ **可以正常工作**

### 2.2 潜在问题场景

#### 场景 1: 路径不规范（相对路径 vs 绝对路径）

**问题**: `root` 可能是相对路径，`resolve()` 后可能改变结构

```python
# 情况 A: 相对路径
root = Path("intermediates/abc123/pic_to_json")
root_abs = root.resolve()  
# 如果当前工作目录是 data/，则 root_abs = data/intermediates/abc123/pic_to_json ✅
# 但如果当前工作目录是其他位置，可能解析错误 ❌

# 情况 B: 绝对路径
root = Path("F:/lumoscribe2026/data/intermediates/abc123/pic_to_json")
root_abs = root.resolve()  # 保持不变 ✅
```

**风险评估**: 
- 如果 API 调用时传入的是相对路径，且工作目录不正确，可能失败
- 但当前 API 实现中，`input_root` 是字符串，会通过 `Path(req.input_root)` 转换，相对路径会基于当前工作目录解析

#### 场景 2: parent.name 不是有效的 UUID

**问题**: `root_abs.parent.name` 可能不是 UUID 格式

```python
# 正常情况
root_abs = Path("data/intermediates/abc-123-def-456/pic_to_json")
source_file_id = root_abs.parent.name  # "abc-123-def-456" ✅

# 异常情况 A: parent 不是 UUID
root_abs = Path("data/intermediates/invalid_name/pic_to_json")
source_file_id = root_abs.parent.name  # "invalid_name" ❌ 不是 UUID

# 异常情况 B: parent 是 intermediates 目录本身
root_abs = Path("data/intermediates/pic_to_json")  # 缺少 {id} 层
source_file_id = root_abs.parent.name  # "intermediates" ❌ 不是 UUID
```

**当前代码处理**:
```python
# knowledge_base_service.py:583
if self.source_file_repository is not None and _UUID_RE.match(source_file_id):
    sf = self.source_file_repository.get_by_id(source_file_id)
    # ...
```

**分析**: 
- 代码**有检查** UUID 格式（`_UUID_RE.match`）
- 但如果 `source_file_id` 不是 UUID，只是跳过数据库查询，不会报错
- 这可能导致 `source_file_id` 使用错误的值，影响后续的元数据追溯

#### 场景 3: 路径结构不符合预期

**问题**: 如果传入的路径不是 `intermediates/{id}/pic_to_json` 结构

```python
# 情况 A: 缺少 pic_to_json 层
root = Path("data/intermediates/abc123")  # 直接是 {id} 目录
root_kind = "abc123"  # 不是 "pic_to_json"
# 会走 else 分支，使用 rglob 查找 md 文件 ✅ 可以工作，但逻辑不一致

# 情况 B: 多了一层目录
root = Path("data/intermediates/abc123/pic_to_json/subdir")
root_kind = "subdir"  # 不是 "pic_to_json"
# 会走 else 分支 ❌ 可能找不到正确的 md 文件

# 情况 C: 路径完全错误
root = Path("data/sources/abc123")
root_kind = "sources"  # 不是 "pic_to_json"
# 会走 else 分支，可能找到错误的文件 ❌
```

#### 场景 4: 多个 md 文件的情况

**问题**: `pic_to_json` 目录下有多个 md 文件

```python
# 当前代码要求只有 1 个 md 文件
if len(md_files) != 1:
    raise AppError(...)
```

**分析**:
- 这是**设计约束**，不是 bug
- 但如果 T094 输出多个 md 文件，会导致构建失败
- 需要确认 T094 是否保证只输出 1 个 md 文件

## 3. 实际调用路径追踪

### 3.1 API 调用路径

```
1. POST /v1/kb/build
   ↓
2. build_kb() in kb.py:144
   ↓
3. kb_service.build_from_t094_output()
   ↓
4. KnowledgeBaseService.build_from_t094_output() in knowledge_base_service.py:381
   ↓
5. root = options.input_root  # Path 对象
   root_abs = root.resolve()   # 绝对路径
   ↓
6. root_kind = root_abs.name.lower()  # ⚠️ 关键判断点
```

### 3.2 输入路径来源

**API 请求**:
```python
# kb.py:60-65
class KBBuildRequest(BaseModel):
    input_root: str = Field(
        ...,
        min_length=1,
        description="输入根目录（例如 data/intermediates/{source_file_id}/pic_to_json）",
    )
```

**实际调用示例**:
```python
# 正常调用
req = KBBuildRequest(
    input_root="data/intermediates/abc-123-def-456/pic_to_json"
)
options = KnowledgeBaseBuildOptions(
    input_root=Path(req.input_root)  # 转换为 Path
)
```

**潜在问题**:
- 如果传入的是相对路径，且当前工作目录不是项目根目录，`resolve()` 可能解析错误
- 如果传入的是绝对路径，应该没问题

## 4. 边界情况测试场景

### 4.1 测试用例设计

| 测试场景 | 输入路径 | 预期行为 | 实际行为 | 状态 |
|---------|---------|---------|---------|------|
| 正常路径（相对） | `data/intermediates/{uuid}/pic_to_json` | ✅ 成功 | ✅ | 通过 |
| 正常路径（绝对） | `F:/lumoscribe2026/data/intermediates/{uuid}/pic_to_json` | ✅ 成功 | ✅ | 通过 |
| 缺少 {id} 层 | `data/intermediates/pic_to_json` | ❌ 失败（parent 不是 UUID） | ⚠️ 可能成功但 source_file_id 错误 | **问题** |
| 多一层目录 | `data/intermediates/{uuid}/pic_to_json/subdir` | ❌ 失败（root_kind 不是 pic_to_json） | ⚠️ 走 else 分支，可能找到错误文件 | **问题** |
| parent 不是 UUID | `data/intermediates/invalid_name/pic_to_json` | ❌ 失败 | ⚠️ 可能成功但 source_file_id 错误 | **问题** |
| 多个 md 文件 | `data/intermediates/{uuid}/pic_to_json/*.md` (2个) | ❌ 失败 | ✅ 正确报错 | 通过 |
| 没有 md 文件 | `data/intermediates/{uuid}/pic_to_json/` (空) | ❌ 失败 | ✅ 正确报错 | 通过 |

### 4.2 关键风险点

1. **缺少路径结构验证**: 代码只检查目录名是否为 `pic_to_json`，不验证完整的路径结构
2. **source_file_id 提取不严格**: 如果 `parent.name` 不是 UUID，代码不会报错，只是跳过数据库查询
3. **错误信息不够明确**: 当路径不符合预期时，错误信息不能帮助用户快速定位问题

## 5. 修复建议

### 5.1 增强路径验证（推荐）

```python
def _validate_and_extract_source_id(root: Path) -> tuple[str, str]:
    """验证输入根目录结构并提取 source_file_id。
    
    Args:
        root: 输入根目录路径
        
    Returns:
        (root_kind, source_file_id)
        
    Raises:
        AppError: 如果路径结构不符合预期
    """
    root_abs = root.resolve()
    
    # 检查是否是 intermediates/{id}/pic_to_json 结构
    if root_abs.name.lower() == "pic_to_json":
        parent = root_abs.parent
        
        # 验证 parent 是有效的 UUID
        if not parent.name or not _UUID_RE.match(parent.name):
            raise AppError(
                code="kb_invalid_path_structure",
                message=(
                    f"pic_to_json 的父目录应为有效的 UUID (source_file_id): {parent}\n"
                    f"期望路径格式: data/intermediates/{{source_file_id}}/pic_to_json/\n"
                    f"实际路径: {root_abs}"
                ),
                status_code=400,
            )
        
        # 验证再上一级是 intermediates
        grandparent = parent.parent
        if grandparent.name.lower() != "intermediates":
            raise AppError(
                code="kb_invalid_path_structure",
                message=(
                    f"路径结构不符合预期: {root_abs}\n"
                    f"期望路径格式: data/intermediates/{{source_file_id}}/pic_to_json/\n"
                    f"实际路径: {root_abs}"
                ),
                status_code=400,
            )
        
        return "pic_to_json", parent.name
    
    # 其他路径结构的处理（向后兼容）
    return "other", "unknown"
```

### 5.2 改进错误信息

```python
if root_kind == "pic_to_json":
    md_files = sorted([p for p in root_abs.glob("*.md") if p.is_file()])
    if len(md_files) != 1:
        raise AppError(
            code="kb_invalid_input",
            message=(
                f"pic_to_json 目录下应且仅应包含 1 个 md 文件\n"
                f"输入路径: {root}\n"
                f"期望路径格式: data/intermediates/{{source_file_id}}/pic_to_json/\n"
                f"实际找到: {len(md_files)} 个 md 文件\n"
                f"文件列表: {[p.name for p in md_files]}"
            ),
            status_code=400,
        )
```

### 5.3 统一路径解析

```python
# 在 build_from_t094_output 开始处
root_kind, source_file_id_from_path = _validate_and_extract_source_id(root)

# 后续使用
if root_kind == "pic_to_json":
    # 使用已验证的 source_file_id
    source_file_id = source_file_id_from_path
    # ...
```

## 6. 风险评估总结

| 风险 | 概率 | 影响 | 当前缓解措施 | 建议 |
|-----|------|------|------------|------|
| 路径结构不匹配 | 中 | 高 | 无 | **立即修复** - 增强路径验证 |
| source_file_id 提取错误 | 低 | 中 | 部分（UUID 检查） | **建议修复** - 严格验证 |
| 错误信息不明确 | 高 | 低 | 无 | **建议修复** - 改进错误信息 |
| 相对路径解析错误 | 低 | 中 | 无 | **监控** - 确保 API 调用使用正确路径 |

## 7. 结论

**当前代码在正常路径结构下可以工作**，但存在以下问题：

1. ⚠️ **缺少路径结构验证**: 不验证完整的 `intermediates/{id}/pic_to_json` 结构
2. ⚠️ **source_file_id 提取不严格**: 如果路径不规范，可能提取错误的值
3. ⚠️ **错误信息不够明确**: 不利于问题排查

**建议优先级**:
- **P0**: 增强路径验证逻辑（防止路径结构错误导致构建失败）
- **P1**: 改进错误信息（提升可维护性）
